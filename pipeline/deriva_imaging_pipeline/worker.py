#!/usr/bin/python
# 
# Copyright 2017 University of Southern California
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
Client for generating tiled pyramid.
"""

import os
import stat
import subprocess
import json
from urllib.parse import urlparse
import sys
import traceback
import time
import shutil
import hashlib
import smtplib
from email.mime.text import MIMEText
import socket
from dateutil.parser import parse
from lxml.etree import XMLSyntaxError
from lxml import etree
from socket import gaierror, EAI_AGAIN
import mimetypes
import tempfile

from deriva.core import PollingErmrestCatalog, HatracStore, urlquote
from deriva.core.utils import hash_utils as hu
from deriva.core.utils.core_utils import DEFAULT_CHUNK_SIZE

from requests.exceptions import HTTPError
from http import HTTPStatus

import xml.etree.ElementTree as ET
import re
import math
from tifffile import TiffFile, TiffWriter

mail_footer = 'Do not reply to this message.  This is an automated message generated by the system, which does not receive email messages.'

store_ome = False
thumbnail_size=96
inches_per_meter = 39.3701
BF_ENV = dict(os.environ, **{'BF_MAX_MEM': '24g'})
uuid = b'urn:uuid:'
endTokens = [b'"', b'<']   
ISI_NETWORK = '128.9' 

class DerivaImagingWorker (object):
    """Network client for generating tiled pyramid images.
    """

    def __init__(self, kwargs):
        self.missing_scenes = False
        self.z_threshold = os.getenv('z_threshold', 5)
        self.model = kwargs.get('model')
        self.hatrac_template = kwargs.get('hatrac_template')
        self.iiif_url = kwargs.get('iiif_url')
        self.compression_level = os.getenv('compression_level', 80)
        self.tile_size = os.getenv('tile_size', 1024)
        self.baseuri = kwargs.get('baseuri')
        o = urlparse(self.baseuri)
        self.scheme = o[0]
        host_port = o[1].split(':')
        self.host = host_port[0]
        self.path = o.path
        self.port = None
        if len(host_port) > 1:
            self.port = host_port[1]
        self.version = kwargs.get('version')
        self.tiffinfo = kwargs.get('tiffinfo')
        self.extract_scenes = kwargs.get('extract_scenes')
        self.python_app = kwargs.get('python_app')
        self.viewer = kwargs.get('viewer')
        self.data_scratch = kwargs.get('data_scratch')
        self.images = kwargs.get('images')
        self.tiff_images = []
        self.thumbnail = None
        self.tiff_files = []
        self.ome_tiff_images = []
        self.ome_tiff_files = []
        self.ome_xml = []
        self.json = None
        self.output_metadata = kwargs.get('output_metadata')
        self.ns = '{http://www.openmicroscopy.org/Schemas/OME/2016-06}'
        self.image_tag = self.ns + 'Image'
        self.pixels_tag = self.ns + 'Pixels'
        self.micrometer = ['\u00b5m', 'Âµm', '?m']
        self.physicalSizeXUnit = 'PhysicalSizeXUnit'
        self.physicalSizeX = 'PhysicalSizeX'
        self.resolutions = None
        self.curl = kwargs.get('curl')
        self.wget = kwargs.get('wget')
        self.cookie = kwargs.get('cookie')
        self.host_server = socket.gethostname()
        self.hatrac_store = HatracStore(
            self.scheme, 
            self.host,
            {'cookie': self.cookie}
        )
        self.store = self.hatrac_store
        self.catalog = PollingErmrestCatalog(
            self.scheme, 
            self.host,
            self.path.split('/')[-1],
            {'cookie': self.cookie}
        )
        self.catalog.dcctx['cid'] = 'pipeline/image/2D/tiff'
        self.mail_server = kwargs.get('mail_server')
        self.mail_sender = kwargs.get('mail_sender')
        self.mail_receiver = kwargs.get('mail_receiver')
        self.mail_file = kwargs.get('mail_file')
        ip = socket.gethostbyname(socket.gethostname())
        network_id = '.'.join(ip.split('.')[:2])
        self.mail_relay = (network_id == ISI_NETWORK)
        self.logger = kwargs.get('logger')
        self.logger.debug('Client initialized.')

    """
    Send email notification
    """
    def sendMail(self, subject, text):
        if self.mail_server and self.mail_sender and self.mail_receiver and self.mail_relay == True:
            """
            Send the mail with the ISI relay.isi.edu SMTP server
            """
            retry = 0
            ready = False
            while not ready:
                try:
                    msg = MIMEText('%s\n\n%s' % (text, mail_footer), 'plain')
                    msg['Subject'] = subject
                    msg['From'] = self.mail_sender
                    msg['To'] = self.mail_receiver
                    s = smtplib.SMTP(self.mail_server)
                    s.sendmail(self.mail_sender, self.mail_receiver.split(','), msg.as_string())
                    s.quit()
                    self.logger.debug('Sent email notification.')
                    ready = True
                except socket.gaierror as e:
                    if e.errno == socket.EAI_AGAIN:
                        time.sleep(100)
                        retry = retry + 1
                        ready = retry > 10
                    else:
                        ready = True
                    if ready:
                        et, ev, tb = sys.exc_info()
                        self.logger.error('got exception "%s"' % str(ev))
                        self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('got exception "%s"' % str(ev))
                    self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                    ready = True
        elif self.mail_file != None:
            """
            Put the mail message into the mail.log file
            """
            fw = open(self.mail_file, 'a')
            fw.write('Subject: {}\n'.format(subject))
            fw.write('Body:\n{}\n\n'.format(text))
            fw.close()
            
            return
            """
            Send the mail with the Linux mail utility
            """
            bash_cmd = '/usr/bin/bash'
            mail_cmd = '/usr/bin/mail'
            scriptName = '/tmp/sendEmail.sh'
            bodyName = '/tmp/body.txt'
            
            fw = open(bodyName, 'w')
            fw.write('{}'.format(text))
            fw.close()
        
            command = "{} -r '{}' -s '{}' {} < {}".format(mail_cmd, self.mail_sender, subject, self.mail_receiver, bodyName)
            fw = open(scriptName, 'w')
            fw.write('{}\n'.format(command))
            fw.close()
            os.chmod('{}'.format(scriptName), stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IXOTH)
            
            self.logger.debug('Mail command: {}'.format(command))
            args = [bash_cmd, scriptName]
            self.logger.debug('Executing:\n%s' % (' '.join(args)))
            p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdoutdata, stderrdata = p.communicate()
            returncode = p.returncode
                
            if returncode != 0:
                self.logger.error('Can not send email.\nError Code:%d\nstdoutdata: %s\nstderrdata: %s\n' % (returncode, stdoutdata.decode('utf-8'), stderrdata.decode('utf-8'))) 
        
            os.remove(scriptName)
            os.remove(bodyName)

    """
    Get the meterScaleInPixels
    """
    def getMeterScaleInPixels(self, filename, rid):
        path = '/var/www/html/%s/%s' % (self.images, filename)
        resolution = 0
        if filename.endswith('.jpg'):
            return resolution
        args = [self.tiffinfo, path]
        self.logger.debug('Executing:\n%s' % (' '.join(args)))
        p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdoutdata, stderrdata = p.communicate()
        returncode = p.returncode
        
        if returncode != 0:
            self.logger.error('Can not get resolution for file "%s".\nError Code:%d\nstdoutdata: %s\nstderrdata: %s\n' % (filename, returncode, stdoutdata.decode('utf-8'), stderrdata.decode('utf-8'))) 
            self.sendMail('FAILURE IMAGE PROCESSING: TIFFINFO ERROR', 'RID: %s\nCan not get resolution for file "%s".\nCommand:\n%s\nError Code:%d\nstdoutdata: %s\nstderrdata: %s\n' % (rid, filename, ' '.join(args), returncode, stdoutdata.decode('utf-8'), stderrdata.decode('utf-8')))
        else:
            lines = stdoutdata.decode('utf-8').split('\n')
            for line in lines:
                if 'Resolution:' in line:
                    if line.endswith('pixels/inch') or line.endswith('pixels/cm'):
                        if line.endswith('pixels/inch'):
                            scale_factor = inches_per_meter
                        elif line.endswith('pixels/cm'):
                            scale_factor = 100
                        parts = line.split()
                        if (float(parts[-2]) * scale_factor) > resolution:
                            resolution = float(parts[-2]) * scale_factor
        
        if resolution == 0:
            self.logger.debug('No resolution found for file "%s".' % (filename)) 
            #self.sendMail('WARNING IMAGE PROCESSING: NO RESOLUTION', 'RID: %s\nCan not find resolution for file "%s".' % (rid, filename))
        return resolution
            
    """
    Get the channel if any
    """
    def getChannel(self, filename, rid):
        for tf in self.tiff_files:
            if tf['name'] == filename:
                return [tf['channel']]
        return None

    """
    Copy the values that are inhereted from parent image into the scenes
    """    
    def getSceneRow(self, parent_row, scene, z_index, z_index_no, rid):
        """
        Inherit columns values from the parent and set values for the rest of the columns
        """
        row = {}
        row[self.model['processing_status']] = 'success'
        row['Parent_Image'] = rid
        if self.resolutions != None and len(self.resolutions) > 0:
            row['Pixels_Per_Meter'] = self.resolutions[0]
        parent_original_file_name = parent_row['Original_File_Name']
        if parent_original_file_name == None:
            parent_original_file_name = rid
            file_name = rid
        else:
            try:
                index = parent_original_file_name.rindex('.')
                file_name = parent_original_file_name[0:index]
            except:
                file_name = parent_original_file_name
        row['Default_Z'] = z_index
        row['Series'] = scene
        row['Original_File_Name'] = '{} (image {})'.format(parent_original_file_name, scene)
        row['Generated_Zs'] = 1 if z_index_no <= self.z_threshold else z_index_no
        row['Properties'] = self.tiff_files[scene]['series_properties']
        return row
        
    """
    Create a record to be stored into the Image table
    """    
    def getImageRow(self, primary_row, rid):
        row = {}
        row['Original_File_Name'] = primary_row[self.model['primary_file_name']]
        row['Primary_Table'] = rid
        return row
    
    """
    Get the Image Metadata from the pyramid
    """
    def getImageMetadata(self, pyramid, rid):
        ret = {
            'ome': pyramid['series_details'],
            'info': {}
            }
        info = ret['info']
        for key,value in pyramid.items():
            if key == 'series_details':
                continue
            if key == 'z':
                info['z_index'] = value
                continue
            if key == 'channel':
                info['channel_number'] = value
            else:
                info[key] = value
                
        return ret

    """
    Main function to process the image
    """
    def processImage(self, rid):
        """
        Cleanup the working directories
        """
        self.cleanupDataScratch()
        self.removeConvertedFiles()
        
        """
        Query for detecting the image to be processed:
        
        /entity/{primary_schema}:{primary_table}/RID={rid}
        
        """
        url = '/entity/{}:{}/RID={}'.format(urlquote(self.model['primary_schema']), urlquote(self.model['primary_table']), urlquote(rid))
        self.logger.debug('Primary table query URL: "{}"'.format(url)) 
        
        resp = self.catalog.get(url)
        resp.raise_for_status()
        row = resp.json()[0]
        self.hatrac_prefix = self.hatrac_template.format(**row)
        filename = row[self.model['primary_file_name']]
        file_url = row[self.model['primary_file_url']]
        primary_row = row
        
        """
        Check if the primary image has a thumbnail uploaded by the user:
        
        """
        self.primary_thumbnail = None
        self.primary_file_thumbnail = self.model.get('primary_file_thumbnail')
        if self.primary_file_thumbnail != None:
            """
            Query for detecting if the primary image has a thumbnail uploaded by the user:
            
            /entity/{primary_schema}:{primary_table}/RID={rid}/self.primary_file_thumbnail
            
            """
            url = '/attribute/{}:{}/RID={}/{}'.format(urlquote(self.model['primary_schema']), urlquote(self.model['primary_table']), urlquote(rid), self.primary_file_thumbnail)
            self.logger.debug('Primary thumbnail query URL: "{}"'.format(url)) 
            resp = self.catalog.get(url)
            resp.raise_for_status()
            if len(resp.json()) > 0:
                primary_thumbnail_column = self.primary_file_thumbnail.split('/')[-1]
                self.primary_thumbnail = resp.json()[0][primary_thumbnail_column]
        self.logger.debug('Primary thumbnail value: "{}"'.format(self.primary_thumbnail)) 

        """
        Query for getting the Image record:
        
        /entity/{image_schema}:{image_table}/Primary_Table=rid
        
        """
        url = '/entity/{}:{}/Primary_Table={}'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_table']), urlquote(rid))
        self.logger.debug('Query to check if the Image record exists: "{}"'.format(url)) 
        resp = self.catalog.get(url)
        resp.raise_for_status()
        rows = resp.json()

        """
        Create the Image record if necessary
        """
        if len(rows) == 0:
            """
            POST url:
            
            /entity/{image_schema}:{image_table}
            
            """
            url = '/entity/{}:{}'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_table']))
            image_row = self.getImageRow(primary_row, rid)
            image_rid = self.createRecord(url, image_row, rid)
            if image_rid == None:
                return 1

        """
        Query for getting the Image record:
        
        /entity/{image_schema}:{image_table}/Primary_Table=rid]
        
        """
        url = '/entity/{}:{}/Primary_Table={}'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_table']), urlquote(rid))
        self.logger.debug('Query for getting the Image record: "{}"'.format(url)) 
        resp = self.catalog.get(url)
        resp.raise_for_status()
        row = resp.json()[0]
        image_row = row
        
        """
        Extract the file from hatrac
        """
        f = self.getHatracFile(filename.replace(' ', '_'), file_url, rid)        
        
        if f == None:
            """
            Update the image table with the failure result.
            """
            
            self.updateAttributes(self.model['primary_schema'],
                                  self.model['primary_table'],
                                  rid,
                                  [self.model['processing_status']],
                                  {'RID': rid,
                                  self.model['processing_status']: 'error'
                                  })
            
            self.logger.debug('Hatrac error') 
            return 1
                    
        """
        Convert the image to a tiled pyramid
        Run the conversion script
        """
        returncode = self.convert2pyramid(f, rid)
        
        if returncode != 0:
            self.removeConvertedFiles()
            
            """
            Update the image table with the failure result.
            """
            self.updateAttributes(self.model['primary_schema'],
                                  self.model['primary_table'],
                                  rid,
                                  [self.model['processing_status']],
                                  {'RID': rid,
                                  self.model['processing_status']: 'error'
                                  })
            self.logger.debug('convert2pyramid error') 
            return 1
        
        for pyramid in self.tiff_files:
            if pyramid['series_details']['Thumbnail series'] == True:
                self.thumbnail = None
                
        if self.thumbnail != None:
            self.logger.debug('Thumbnail:\n{}'.format(json.dumps(self.thumbnail, indent = 4))) 

        self.logger.debug('TIFF Generated Files:\n{}'.format(json.dumps(self.tiff_files, indent = 4))) 
        self.logger.debug('OME TIFF Generated Files:\n{}'.format(json.dumps(self.ome_tiff_files, indent = 4))) 
        self.logger.debug('TIFF Generated Images:\n{}'.format(json.dumps(self.tiff_images, indent = 4))) 
        self.logger.debug('OME TIFF Generated Images:\n{}'.format(json.dumps(self.ome_tiff_images, indent = 4))) 
        self.logger.debug('OME Companion: {}'.format(json.dumps(self.ome_xml, indent = 4))) 
        self.logger.debug('JSON: {}'.format(self.json)) 
        self.logger.debug('Resolutions: {}'.format(self.resolutions))
        
        """
        Set the image metadata into the pyramids tiff files
        """
        self.set_image_properties(rid)
        
        """
        Check that the metadata can be accessed
        """
        returncode = self.checkInfoJSON(rid)
        if returncode != 0:
            self.removeConvertedFiles()
            
            """
            Update the image table with the failure result.
            """
            self.updateAttributes(self.model['primary_schema'],
                                  self.model['primary_table'],
                                  rid,
                                  [self.model['processing_status']],
                                  {'RID': rid,
                                  self.model['processing_status']: 'error'
                                  })
            return 1
        
        """
        Check that the thumbnail can be accessed
        """
        returncode = self.checkThumbnailURL(rid)
        if returncode != 0:
            self.removeConvertedFiles()
            
            """
            Update the image table with the failure result.
            """
            self.updateAttributes(self.model['primary_schema'],
                                  self.model['primary_table'],
                                  rid,
                                  [self.model['processing_status']],
                                  {'RID': rid,
                                  self.model['processing_status']: 'error'
                                  })
            return 1
        
        """
        Set the viewer URI for the scenes
        """
        returncode = self.processTiffPyramids(image_row, rid)

        if returncode != 0:
            error_name = 'GET TIFF URL ERROR'
            if returncode == None:
                error_name = None
            """
            Update the image table with the failure result.
            """
            self.removeConvertedFiles()
            self.updateAttributes(self.model['primary_schema'],
                                 self.model['primary_table'],
                                 rid,
                                 [self.model['processing_status']],
                                 {'RID': rid,
                                  self.model['processing_status']: 'error'
                                 })
            return 1
            
        self.removeConvertedFiles()
        
        """
        Update the image table with the success result.
        """
        obj = {}
        obj['RID'] = rid
        obj[self.model['processing_status']] = 'error' if self.missing_scenes == True else 'success'
        columns = [self.model['processing_status']]

        self.updateAttributes(self.model['primary_schema'],
                              self.model['primary_table'],
                              rid,
                              columns,
                              obj)
        
        self.logger.debug('SUCCEEDED created the tiled pyramid images for the file "%s".' % (filename)) 
        
        self.logger.debug('Ended Image Processing for the {};{} table.'.format(self.model['primary_schema'], self.model['primary_table'])) 
        
        return 0
        
    """
    Extract the file from hatrac
    """
    def getHatracFile(self, filename, file_url, rid):
        try:
            hatracFile = '{}/{}'.format(self.data_scratch, filename)
            self.store.get_obj(file_url, destfilename=hatracFile)
            self.logger.debug('File "%s", %d bytes.' % (hatracFile, os.stat(hatracFile).st_size)) 
            return hatracFile
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('{}'.format(''.join(traceback.format_exception(et, ev, tb))))
            self.sendMail('FAILURE IMAGE PROCESSING: HATRAC GET ERROR', 'RID: {}\n{}\n'.format((rid, ''.join(traceback.format_exception(et, ev, tb)))))
            os.remove(hatracFile)
            return None

    """
    Get the hatrac thumbnail URL
    Namespace: /facebase/data/fb3/{dataset}/{replicate}/proc_img/{RID}/<filename>
    """
    def getThumbnailHatracURL(self, thumbnail_pattern, converted_file_name, rid):
        hatrac_uri = '{}/{}/{}'.format(self.hatrac_prefix, urlquote(rid), urlquote(converted_file_name))
        return thumbnail_pattern % (urlquote(hatrac_uri))
    
    """
    Generate the thumbnail pattern
    """
    def getThumbnailPattern(self):
        thumbnail_pattern = '/iiif/2/%s/full/,150/0/default.jpg' 
        return thumbnail_pattern
            
    """
    Get the MD5 of the file after removing the UUID value
    """
    def getBaseMD5(self, file_name, file_path=None):
        if file_path == None:
            file_path = '/var/www/html/{}'.format(self.images)
        md5 = None
        try:
            outfile = '%s/%s.tmp' % (self.data_scratch, file_name)
            fw = open(outfile, 'wb')
            with open('{}/{}'.format(file_path, file_name), 'rb') as fr:
                for chunk in fr:
                    if uuid in chunk:
                        i = chunk.index(uuid)
                        fw.write(chunk[:i])
                        ready = False
                        while not ready:
                            j = i
                            while j < len(chunk) and chunk[j:j+1] not in endTokens:
                                j = j+1
                            try:
                                i = chunk.index(uuid, j)
                                fw.write(chunk[j:i])
                            except:
                                fw.write(chunk[j:])
                                ready = True
                    else:
                        fw.write(chunk)
                        
            fw.close() 
            hashes = hu.compute_file_hashes(outfile, hashes=['md5', 'sha256'])
            md5 = hashes['md5'][0]
            self.logger.debug('The base MD5 of the file {} is:{}'.format(file_name, md5))
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('Can not get the base MD5 of the file "%s". Error: "%s"' % (file_name, str(ev)))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            fw.close()  
             
        self.logger.debug('Removing file "%s"' % (outfile))
        os.remove(outfile)
        
        return md5
            
    """
    Get the info related to a companion.ome file 
    """
    def getCompanionInfo(self, scene, z, companion):
        """
        Get the info related to a companion.ome file 
        """
        for companion_ome in companion:
            url,name,bytes,md5 = companion_ome
            if z != None:
                try:
                    r = re.search('(.*)[-](s[0-9]+)[-](z[0-9]+)[.]companion[.]ome$', name)
                    filename = r.group(1)
                    series = int(r.group(2)[1:])
                    z_index = int(r.group(3)[1:])
                    if z_index == z and scene == series:
                        return companion_ome
                except:
                    pass
            else:
                try:
                    r = re.search('(.*)[-](s[0-9]+)[.]companion[.]ome$', name)
                    filename = r.group(1)
                    series = int(r.group(2)[1:])
                    if scene == series:
                        return companion_ome
                except:
                    if scene == None:
                        return companion_ome
    
        return (None, None, None, None)

    """
    Set the image metadata into the pyramids tiff files
    """
    def set_image_properties(self, rid):
        series_no = 0
        z_index_no = 0
        channels_no = 0
        for pyramid in self.tiff_files:
            try:
                pyramid['Pixels_Per_Meter'] = self.getPixelsPerMeter(pyramid['series_details']['PhysicalSizeXUnit'], pyramid['series_details']['PhysicalSizeX'], rid)
            except:
                pyramid['Pixels_Per_Meter'] = None
                
            if pyramid['series_details']['Thumbnail series'] == True:
                continue
            if pyramid['z'] > z_index_no:
                z_index_no = pyramid['z']
            if pyramid['series'] > series_no:
                series_no = pyramid['series']
            if pyramid['channel'] > channels_no:
                channels_no = pyramid['channel']

        series_no += 1
        z_index_no += 1
        channels_no += 1
        
        pyramid = self.tiff_files[0]
        series_details =  pyramid['series_details']
        is_rgb = series_details['RGB']
        pixels_per_meter = pyramid['Pixels_Per_Meter']
        image_properties = {'Number_Of_ Series': series_no,
                            'Number_Of_ Channels': channels_no,
                            'Number_Of_Z_Index': z_index_no,
                            'IS_RGB': is_rgb,
                            'Pixels_Per_Meter': pixels_per_meter,
                            'Channels': {}
                            }
        channel_number = 0
        for channel in series_details['Channels']:
            channel_name = channel.get('Name', 'Unknown')
            channel_color = channel.get('Color', None)
            if channel_color != None:
                channel_color = '#' + channel_color[2:]
            channel_properties = {'Channel_Number': channel_number,
                                  'Color': channel_color
                }
            image_properties['Channels'][channel_name] = channel_properties
            channel_number +=1
        
    """
    Populate the Image table with the scenes
    """
    def processTiffPyramids(self, parent_row, rid):
        """
        Get the series
        """
        series = []
        scenes = {}
        max_z_index = 0
        series_no = 0
        z_index_no = 0
        channels_no = 0
        for pyramid in self.tiff_files:
            try:
                pyramid['Pixels_Per_Meter'] = self.getPixelsPerMeter(pyramid['series_details']['PhysicalSizeXUnit'], pyramid['series_details']['PhysicalSizeX'], rid)
            except:
                pyramid['Pixels_Per_Meter'] = None
                self.logger.info('No Pixels_Per_Meter found for file {}.'.format(pyramid['name']))
                et, ev, tb = sys.exc_info()
                self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                
            if pyramid['series_details']['Thumbnail series'] == True:
                continue
            if pyramid['z'] > max_z_index:
                max_z_index = pyramid['z']
            if pyramid['series'] not in series:
                series.append(pyramid['series'])
            if pyramid['z'] > z_index_no:
                z_index_no = pyramid['z']
            if pyramid['series'] > series_no:
                series_no = pyramid['series']
            if pyramid['channel'] > channels_no:
                channels_no = pyramid['channel']

        series_no += 1
        z_index_no += 1
        channels_no += 1
        middle_z_index = max_z_index // 2
        
        """
        Store the JSON and XML 
        """
        Metadata_URL, Metadata_Name, Metadata_Bytes, Metadata_MD5 = self.storeFileInHatrac(self.json, '/var/www/html/{}'.format(self.output_metadata), rid)
        if (Metadata_URL, Metadata_Name, Metadata_Bytes, Metadata_MD5) == (None, None, None, None):
            return 1
        companion = []
        for companion_ome in self.ome_xml:
            try:
                r = re.search('.*[-]s[0-9]+[-]z([0-9]+)[.]companion[.]ome', companion_ome).group(1)
                if z_index_no <= self.z_threshold and int(r) == middle_z_index or z_index_no > self.z_threshold:
                    companion_file = self.storeFileInHatrac(companion_ome, '/var/www/html/{}'.format(self.output_metadata), rid)
                    if companion_file == (None, None, None, None):
                        return 1
                    else:
                        companion.append(companion_file)
            except:
                companion_file = self.storeFileInHatrac(companion_ome, '/var/www/html/{}'.format(self.output_metadata), rid)
                if companion_file == (None, None, None, None):
                    return 1
                else:
                    companion.append(companion_file)

        """
        Get the scenes
        
        /attribute/{image_schema}:{image_table}/Parent_Image={rid}/RID,Series@sort(Series)
        
        """
        url = '/attribute/{}:{}/Parent_Image={}/RID,Series@sort(Series)'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_table']), parent_row['RID'])
        resp = self.catalog.get(url)
        resp.raise_for_status()
        rows = resp.json()
        update_scenes = (len(rows) > 0)
        if update_scenes == True:
            self.logger.debug('Image Scenes to be updated: {}'.format(json.dumps(rows, indent = 4)))
        
        scene_rows = rows

        """
        Delete the references from Processed_Image for the scenes
        """
        scene_rows.append({'RID': parent_row['RID'], 'Series': None})
        for scene_row in scene_rows:
            image_rid = scene_row['RID']
            """
            /attribute/{image_schema}:{processed_image}/Reference_Image={image_rid}/RID
            """
            url = '/attribute/{}:{}/Reference_Image={}/RID'.format(urlquote(self.model['image_schema']), urlquote(self.model['processed_image']), image_rid)
            resp = self.catalog.get(url)
            resp.raise_for_status()
            rows = resp.json()
            if len(rows) > 0:
                self.logger.debug('Processed_Image to be deleted: {}'.format(json.dumps(rows, indent = 4)))
                """
                /entity/{image_schema}:{processed_image}/Reference_Image={image_rid}
                """
                if self.deleteEntity('{}:{}/Reference_Image={}'.format(urlquote(self.model['image_schema']), urlquote(self.model['processed_image']), urlquote(image_rid)), rid) != 0:
                    return 1
        
        """
        Delete the references from Image_Channel
        """
        for scene_row in scene_rows:
            image_rid = scene_row['RID']
            """
            /attribute/{image_schema}:{image_channel}/Image={image_rid}/RID
            """
            url = '/attribute/{}:{}/Image={}/RID'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_channel']), image_rid)
            resp = self.catalog.get(url)
            resp.raise_for_status()
            rows = resp.json()
            if len(rows) > 0:
                self.logger.debug('Image_Channel to be deleted: {}'.format(json.dumps(rows, indent = 4)))
                """
                /entity/{image_schema}:{image_channel}/Image={image_rid}
                """
                if self.deleteEntity('{}:{}/Image={}'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_channel']),  urlquote(image_rid)), rid) != 0:
                    return 1
        
        """
        Delete the references from Image_Z
        """
        for scene_row in scene_rows:
            image_rid = scene_row['RID']
            """
            /attribute/{image_schema}:{image_z}/Image={image_rid}/RID
            """
            url = '/attribute/{}:{}/Image={}/RID'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_z']), image_rid)
            resp = self.catalog.get(url)
            resp.raise_for_status()
            rows = resp.json()
            if len(rows) > 0:
                self.logger.debug('Image_Z to be deleted: {}'.format(json.dumps(rows, indent = 4)))
                """
                /entity/{image_schema}:{image_z}/Image={image_rid}
                """
                if self.deleteEntity('{}:{}/Image={}'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_z']), urlquote(image_rid)), rid) != 0:
                    return 1
        
        """
        Build now the scene rows with middle_z_index
        """
        original_file_name = parent_row['Original_File_Name']
        if original_file_name == None:
            file_name = parent_row['RID']
        else:
            try:
                index = original_file_name.rindex('.')
                file_name = original_file_name[0:index]
            except:
                file_name = original_file_name

        if series_no == 1:
            scenes['0'] = parent_row['RID']
            pyramid = self.tiff_files[0]
            cols = ['Metadata_URL', 'Metadata_Name', 'Metadata_Bytes', 'Metadata_MD5', 
                    'OME_XML_URL', 'OME_XML_Name', 'OME_XML_Bytes', 'OME_XML_MD5', 
                    'Generated_Zs', 'Properties', 'Total_Series', 'Series', 'Default_Z']
            OME_XML_URL, OME_XML_Name, OME_XML_Bytes, OME_XML_MD5 = self.getCompanionInfo(0, None, companion)
            obj = {
                'Metadata_URL': Metadata_URL,
                'Metadata_Name': Metadata_Name, 
                'Metadata_Bytes': Metadata_Bytes, 
                'Metadata_MD5': Metadata_MD5, 
                'OME_XML_URL': OME_XML_URL, 
                'OME_XML_Name': OME_XML_Name, 
                'OME_XML_Bytes': OME_XML_Bytes, 
                'OME_XML_MD5': OME_XML_MD5,
                'Generated_Zs': 1 if z_index_no <= self.z_threshold else z_index_no,
                'Properties': self.tiff_files[0]['series_properties'],
                'Total_Series': None,
                'Series': None,
                'Default_Z': middle_z_index
            }
            if parent_row['Original_File_Name'] == None:
                cols.append('Original_File_Name')
                obj['Original_File_Name'] = '{} (image 0)'.format(parent_row['RID'])
            if len(cols) > 0:
                obj['RID'] = parent_row['RID']
                returncode = self.updateAttributes(self.model['image_schema'],
                                      self.model['image_table'],
                                      rid,
                                      cols,
                                      obj)
                if returncode != 0:
                    return returncode
        else:
            cols = ['Metadata_URL', 'Metadata_Name', 'Metadata_Bytes', 'Metadata_MD5', 
                    'OME_XML_URL', 'OME_XML_Name', 'OME_XML_Bytes', 'OME_XML_MD5', 
                    'Total_Series', 'Generated_Zs', 'Series', 'Properties']
            OME_XML_URL, OME_XML_Name, OME_XML_Bytes, OME_XML_MD5 = self.getCompanionInfo(None, None, companion)
            obj = {
                'Metadata_URL': Metadata_URL,
                'Metadata_Name': Metadata_Name, 
                'Metadata_Bytes': Metadata_Bytes, 
                'Metadata_MD5': Metadata_MD5, 
                'OME_XML_URL': OME_XML_URL, 
                'OME_XML_Name': OME_XML_Name, 
                'OME_XML_Bytes': OME_XML_Bytes, 
                'OME_XML_MD5': OME_XML_MD5,
                'Total_Series': series_no,
                'Generated_Zs': None,
                'Series': None,
                'Properties': None
            }
            if len(cols) > 0:
                obj['RID'] = parent_row['RID']
                returncode = self.updateAttributes(self.model['image_schema'],
                                      self.model['image_table'],
                                      rid,
                                      cols,
                                      obj)
                if returncode != 0:
                    return returncode

            for serie in series:
                """
                Copy the columns from the parent table
                """
                row = self.getSceneRow(parent_row, serie, middle_z_index, z_index_no, parent_row['RID'])
                if update_scenes == False:
                    """
                    POST url: /entity/{image_schema}:{image_table}
                    """
                    scene_rid = self.createRecord('/entity/{}:{}'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_table'])), row, rid)
                    if scene_rid == None:
                        return 1
                    scenes[str(serie)] = scene_rid
                else:
                    scene_rid = scene_rows[serie]['RID']
                    cols = list(row.keys())
                    row['RID'] = scene_rid
                    returncode = self.updateAttributes(self.model['image_schema'],
                                                      self.model['image_table'],
                                                      scene_rid,
                                                      cols,
                                                      row)
                    if returncode != 0:
                        return 1
                    scenes[str(serie)] = scene_rid
            
        """
        Store the tiff files into the Processed_Image table
        """
        for pyramid in self.tiff_files:
            if z_index_no <= self.z_threshold and pyramid['z'] != middle_z_index:
                continue
            file_name = pyramid['name']
            newFile = '/var/www/html/%s/%s' % (self.images, file_name)
            file_size = os.path.getsize(newFile)
            hashes = hu.compute_file_hashes(newFile, hashes=['md5', 'sha256'])
            new_md5 = hashes['md5'][1]
            new_sha256 = hashes['sha256'][1]
            hexa_md5 = hashes['md5'][0]
            hexa_sha256 = hashes['sha256'][0]
            base_md5 = self.getBaseMD5(file_name)
            new_uri = '{}/{}/{}'.format(self.hatrac_prefix, urlquote(rid), urlquote(file_name))
            chunked = True if file_size > DEFAULT_CHUNK_SIZE else False
            
            """
            Store the images in hatrac if they are not already
            """
            hatrac_URI = None
            try:
                outfile = '/var/www/html/%s/%s.hatrac' % (self.images, file_name)
                r = self.store.get_obj(new_uri, destfilename=outfile)
                hatrac_URI = r.headers['Content-Location']
            except:
                pass
                
            if hatrac_URI != None and base_md5 == self.getBaseMD5('{}.hatrac'.format(file_name)):
                self.logger.info('Skipping the upload of the file "%s" as it already exists hatrac.' % file_name)
            else:
                if mimetypes.inited == False:
                    mimetypes.init()
                content_type,encoding = mimetypes.guess_type(newFile)
                if content_type == None:
                    content_type = 'application/octet-stream'
                try:
                    hatrac_URI = self.hatrac_store.put_loc(new_uri,
                                                         newFile,
                                                         headers={'Content-Type': content_type},
                                                         content_disposition = "filename*=UTF-8''%s" % urlquote(file_name),
                                                         md5 = new_md5,
                                                         sha256 = new_sha256,
                                                         content_type = content_type,
                                                         chunked = chunked
                                                       )
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('Can not upload file "%s" in hatrac "%s". Error: "%s"' % (file_name, new_uri, str(ev)))
                    self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                    self.sendMail('FAILURE IMAGE PROCESSING: HATRAC PUT ERROR', 'RID: %s\nCan not upload file "%s" in hatrac "%s". Error: "%s"' % (rid, file_name, new_uri, ''.join(traceback.format_exception(et, ev, tb))))
                    return 1
                
            self.logger.debug('Removing file "%s"' % (outfile))
            os.remove(outfile)
                
            pyramid['Download_Tiff_URL'] = hatrac_URI
            pyramid['Download_Tiff_Name'] = pyramid['name']
            pyramid['Download_Tiff_Bytes'] = file_size
            pyramid['Download_Tiff_MD5'] = base_md5
            
            channels = self.getChannel(file_name, rid)
            config = {
                'tool': 'image_processing',
                'version': self.version,
                'codec': 'jpeg',
                'quality': self.compression_level,
                'tile_size': self.tile_size,
                'is_ome': pyramid['is_ome'],
                'pyramidal': True
                }
            config_tiffinfo = {}
            self.logger.debug('pixels_per_meter: {}'.format(pyramid['Pixels_Per_Meter']))
            self.logger.debug('getMeterScaleInPixels: {}'.format(self.getMeterScaleInPixels(file_name, rid)))
            pixels_per_meter = self.getMeterScaleInPixels(file_name, rid)
            if pixels_per_meter != None:
                config_tiffinfo['pixels_per_meter'] = pixels_per_meter
                
            if len(config_tiffinfo) > 0:
                config['tiffinfo'] = config_tiffinfo
                
            reference_image = parent_row['RID']
            if pyramid['series_details']['Thumbnail series'] == False:
                reference_image = scenes[str(pyramid['series'])]
            row = {'File_Name': file_name,
                   'File_URL': hatrac_URI,
                   'File_Bytes': file_size,
                   'File_MD5': hexa_md5,
                   'Config': config,
                   'Channel_Number': pyramid['channel'],
                   'Z_Index': pyramid['z'],
                   'Reference_Image': reference_image,
                   'Display_Method': 'iiif',
                   }
            
            pyramid['row'] = row
            pyramid['url'] = '/iiif/2/{}/info.json'.format(urlquote('{}'.format(hatrac_URI)))
            thumbnail_pattern = self.getThumbnailPattern()
            thumbnail_url = self.getThumbnailHatracURL(thumbnail_pattern, pyramid['name'], rid)
            pyramid['Default_Thumbnail_URL'] = thumbnail_url
        
        """
        Build now the URLs and thumbnails for each scene
        Select just those for which z_index=middle_z_index
        """
        for serie in series:
            urls = []
            thumbnail_url = None
            download_tiff_url = None
            download_tiff_file_name = None
            download_tiff_file_bytes = None
            download_tiff_file_md5 = None
            metadata = None
            pixels_per_meter = None
            for pyramid in self.tiff_files:
                if pyramid['series'] == serie and pyramid['z'] == middle_z_index:
                    pixels_per_meter = pyramid['Pixels_Per_Meter']
                    if channels_no == 1:
                        download_tiff_url = pyramid['Download_Tiff_URL']
                        download_tiff_file_name = pyramid['Download_Tiff_Name']
                        download_tiff_file_bytes = pyramid['Download_Tiff_Bytes']
                        download_tiff_file_md5 = pyramid['Download_Tiff_MD5']
                    metadata = self.getImageMetadata(pyramid, rid)
                    urls.append(pyramid['url'])
                    thumbnail_url = pyramid['Default_Thumbnail_URL']
            
            scene_uri = '/{}?url={}'.format(self.viewer, '&url='.join(urls))
                    
            OME_XML_URL, OME_XML_Name, OME_XML_Bytes, OME_XML_MD5 = self.getCompanionInfo(serie, None, companion)
            returncode = self.updateAttributes(self.model['image_schema'],
                                            self.model['image_table'],
                                            scenes[str(serie)],
                                            ['Thumbnail_URL', 'Default_Z', 
                                             'Download_Tiff_URL', 'Download_Tiff_Name', 'Download_Tiff_Bytes', 'Download_Tiff_MD5', 
                                             'Pixels_Per_Meter', 
                                             'OME_XML_URL', 'OME_XML_Name', 'OME_XML_Bytes', 'OME_XML_MD5'],
                                            {'RID': scenes[str(serie)],
                                            'Thumbnail_URL': thumbnail_url if self.primary_thumbnail == None else None,
                                            'Default_Z': middle_z_index,
                                            'Download_Tiff_URL': download_tiff_url,
                                            'Download_Tiff_Name': download_tiff_file_name,
                                            'Download_Tiff_Bytes': download_tiff_file_bytes,
                                            'Download_Tiff_MD5': download_tiff_file_md5,
                                            'OME_XML_URL': OME_XML_URL, 
                                            'OME_XML_Name': OME_XML_Name, 
                                            'OME_XML_Bytes': OME_XML_Bytes, 
                                            'OME_XML_MD5': OME_XML_MD5,
                                            'Pixels_Per_Meter': pixels_per_meter
                                  })
            if returncode != 0:
                return returncode
            
        """
        Build now the channels
        """
        for pyramid in self.tiff_files:
            if pyramid['z'] == middle_z_index:
                row = {'Image': scenes[str(pyramid['series'])],
                       'Channel_Number': pyramid['channel'],
                       'Pseudo_Color': None if pyramid['channel_color']==None else '#'+pyramid['channel_color'][2:],
                       'Is_RGB': pyramid['IS_RGB'],
                       'Name': pyramid['channel_name'],
                       'Notes': None
                       }
                image_channel_rid = self.createRecord('/entity/{}:{}'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_channel'])), row, rid)
                if image_channel_rid == None:
                    return 1
                
        """
        Build now the Image_Z record
        """
        for pyramid in self.tiff_files:
            if channels_no > 1:
                if z_index_no <= self.z_threshold and pyramid['z'] != middle_z_index:
                    continue
                
                if pyramid['channel'] != 0:
                    continue
                
                OME_XML_URL, OME_XML_Name, OME_XML_Bytes, OME_XML_MD5 = self.getCompanionInfo(pyramid['series'], pyramid['z'], companion)
                row = {'Image': scenes[str(pyramid['series'])],
                       'Z_Index': pyramid['z'],
                       'OME_Companion_URL': OME_XML_URL,
                       'OME_Companion_Name': OME_XML_Name,
                       'OME_Companion_Bytes': OME_XML_Bytes,
                       'OME_Companion_MD5': OME_XML_MD5
                       }
                image_z_rid = self.createRecord('/entity/{}:{}'.format(urlquote(self.model['image_schema']), urlquote(self.model['image_z'])), row, rid)
                if image_z_rid == None:
                    return 1
                
        """
        Build now the Processed_Image records
        """
        for pyramid in self.tiff_files:
            if 'row' in pyramid.keys():
                if self.createEntity('{}:{}'.format(urlquote(self.model['image_schema']), urlquote(self.model['processed_image'])), pyramid['row'], rid) == None:
                    return 1
                
        if series_no == 1:
            return 0

        """
        Set the values to the original image in case we have multiple scenes
        Set the ome.tif of the original file
        """
        download_tiff_url = None
        download_tiff_file_name = None
        download_tiff_file_bytes = None
        download_tiff_file_md5 = None
        ome_tif_file_name = None

        for pyramid in self.ome_tiff_files:
            if pyramid['series_details'] != None:
                ome_tif_file_name = pyramid['name']
        if ome_tif_file_name != None and store_ome == True:
            file_name = ome_tif_file_name
            newFile = '/var/www/html/%s/%s' % (self.images, file_name)
            file_size = os.path.getsize(newFile)
            hashes = hu.compute_file_hashes(newFile, hashes=['md5', 'sha256'])
            new_md5 = hashes['md5'][1]
            new_sha256 = hashes['sha256'][1]
            base_md5 = self.getBaseMD5(file_name)
            new_uri = '{}/{}/{}'.format(self.hatrac_prefix, urlquote(rid), urlquote(file_name))
            chunked = True if file_size > DEFAULT_CHUNK_SIZE else False
            
            """
            Store the images in hatrac if they are not already
            """
            hatrac_URI = None
            try:
                outfile = '/var/www/html/%s/%s.hatrac' % (self.images, file_name)
                r = self.store.get_obj(new_uri, destfilename=outfile)
                hatrac_URI = r.headers['Content-Location']
            except:
                pass
                
            if hatrac_URI != None and base_md5 == self.getBaseMD5('{}.hatrac'.format(file_name)):
                self.logger.info('Skipping the upload of the file "%s" as it already exists hatrac.' % file_name)
            else:
                if mimetypes.inited == False:
                    mimetypes.init()
                content_type,encoding = mimetypes.guess_type(newFile)
                if content_type == None:
                    content_type = 'application/octet-stream'
                try:
                    hatrac_URI = self.hatrac_store.put_loc(new_uri,
                                                         newFile,
                                                         headers={'Content-Type': content_type},
                                                         content_disposition = "filename*=UTF-8''%s" % urlquote(file_name),
                                                         md5 = new_md5,
                                                         sha256 = new_sha256,
                                                         content_type = content_type,
                                                         chunked = chunked
                                                       )
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('Can not upload file "%s" in hatrac "%s". Error: "%s"' % (file_name, new_uri, str(ev)))
                    self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                    self.sendMail('FAILURE IMAGE PROCESSING: HATRAC PUT ERROR', 'RID: %s\nCan not upload file "%s" in hatrac "%s". Error: "%s"' % (rid, file_name, new_uri, ''.join(traceback.format_exception(et, ev, tb))))
                    return 1

            self.logger.debug('Removing file "%s"' % (outfile))
            os.remove(outfile)

            download_tiff_url = hatrac_URI       
            download_tiff_file_name = ome_tif_file_name
            download_tiff_file_bytes = os.path.getsize(newFile)
            download_tiff_file_md5 = base_md5
        OME_XML_URL, OME_XML_Name, OME_XML_Bytes, OME_XML_MD5 = self.getCompanionInfo(None, None, companion)
        returncode = self.updateAttributes(self.model['image_schema'],
                                          self.model['image_table'],
                                          rid,
                                          ['Thumbnail_URL', 'Default_Z', 
                                           'Download_Tiff_URL', 'Download_Tiff_Name', 'Download_Tiff_Bytes', 'Download_Tiff_MD5', 
                                           'Pixels_Per_Meter', 'Series', 
                                           'Metadata_URL', 'Metadata_Name', 'Metadata_Bytes', 'Metadata_MD5', 
                                           'OME_XML_URL', 'OME_XML_Name', 'OME_XML_Bytes', 'OME_XML_MD5', 
                                           'Total_Series'],
                                          {'RID': rid,
                                          'Thumbnail_URL': None,
                                          'Default_Z': None,
                                          'Download_Tiff_URL': download_tiff_url,
                                          'Download_Tiff_Name': download_tiff_file_name,
                                          'Download_Tiff_Bytes': download_tiff_file_bytes,
                                          'Download_Tiff_MD5': download_tiff_file_md5,
                                          'Pixels_Per_Meter': None,
                                          'Series': None,
                                        'Metadata_URL': Metadata_URL,
                                        'Metadata_Name': Metadata_Name, 
                                        'Metadata_Bytes': Metadata_Bytes, 
                                        'Metadata_MD5': Metadata_MD5, 
                                        'OME_XML_URL': OME_XML_URL, 
                                        'OME_XML_Name': OME_XML_Name, 
                                        'OME_XML_Bytes': OME_XML_Bytes, 
                                        'OME_XML_MD5': OME_XML_MD5,
                                        'Total_Series': series_no
                                          })
        
        return returncode

    """
    Check that the info.json can be accessed
    """
    def checkInfoJSON(self, rid):
        for file_name in self.tiff_images:
            file_path = '/var/www/html/%s%s%s' % (self.images, os.sep, file_name)
            if os.path.isfile(file_path):
                args = [self.curl, '-s', '-k', '-w', '%{http_code}', '-o', '/dev/null', '{}/{}/info.json'.format(self.iiif_url, urlquote('https://{}/{}/{}'.format(self.host_server, self.images, urlquote(file_name))))]
                try:
                    self.logger.debug('Executing:\n%s' % (' '.join(args)))
                    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    stdoutdata, stderrdata = p.communicate()
                    returncode = p.returncode
                    if returncode == 0:
                        http_status_code = int (stdoutdata)
                        if http_status_code != 200:
                            self.logger.error('File "%s" has returned HTTP Status Code %d' % (file_name, http_status_code))
                            self.sendMail('FAILURE IMAGE PROCESSING: HTTP ERROR', 'RID: %s\nCurl command (checkInfoJSON):\n%s\nhas returned HTTP Status Code %d for the file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (rid, ' '.join(args), http_status_code, file_name, stdoutdata.decode('utf-8'), stderrdata.decode('utf-8')))
                            return 1
                    else:
                        self.logger.error('Returned code %d' % (returncode))
                        self.logger.error('stdout: %s' % stdoutdata.decode('utf-8'))
                        self.logger.error('stderr: %s' % stderrdata.decode('utf-8'))
                        self.sendMail('FAILURE IMAGE PROCESSING: HTTP ERROR', 'RID: %s\nCurl command (checkInfoJSON):\n%s \nhas returned %d for the file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (rid, ' '.join(args), returncode, file_name, stdoutdata.decode('utf-8'), stderrdata.decode('utf-8')))
                        return 1
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('got unexpected exception "%s"' % str(ev))
                    self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                    self.sendMail('FAILURE IMAGE PROCESSING: HTTP ERROR', 'RID: %s\nCurl command (checkInfoJSON):\n%s \ncould not be executed for the file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (rid, ' '.join(args), file_name, stdoutdata.decode('utf-8'), stderrdata.decode('utf-8')))
                    return 1

        return 0
        
    """
    Check that the thumbnail can be accessed
    """
    def checkThumbnailURL(self, rid):
        for file_name in self.tiff_images:
            file_path = '/var/www/html/%s%s%s' % (self.images, os.sep, file_name)
            if os.path.isfile(file_path):
                args = [self.curl, '-s', '-k', '-w', '%{http_code}', '-o', '/dev/null', '{}/{}/full/,150/0/default.jpg'.format(self.iiif_url, urlquote('https://{}/{}/{}'.format(self.host_server, self.images, urlquote(file_name))))]
                try:
                    self.logger.debug('Executing:\n%s' % (' '.join(args)))
                    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                    stdoutdata, stderrdata = p.communicate()
                    returncode = p.returncode
                    if returncode == 0:
                        http_status_code = int (stdoutdata)
                        if http_status_code != 200:
                            self.logger.error('File "%s" has returned HTTP Status Code %d' % (file_name, http_status_code))
                            self.sendMail('FAILURE IMAGE PROCESSING: HTTP ERROR', 'RID: %s\nCurl command (checkThumbnailURL):\n%s\nhas returned HTTP Status Code %d for the file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (rid, ' '.join(args), http_status_code, file_name, stdoutdata.decode('utf-8'), stderrdata.decode('utf-8')))
                            return 1
                    else:
                        self.logger.error('Returned code %d' % (returncode))
                        self.logger.error('stdout: %s' % stdoutdata.decode('utf-8'))
                        self.logger.error('stderr: %s' % stderrdata.decode('utf-8'))
                        self.sendMail('FAILURE IMAGE PROCESSING: HTTP ERROR', 'RID: %s\nCurl command (checkThumbnailURL):\n%s \nhas returned %d for the file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (rid, ' '.join(args), returncode, file_name, stdoutdata.decode('utf-8'), stderrdata.decode('utf-8')))
                        return 1
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('got unexpected exception "%s"' % str(ev))
                    self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                    self.sendMail('FAILURE IMAGE PROCESSING: HTTP ERROR', 'RID: %s\nCurl command (checkThumbnailURL):\n%s \ncould not be executed for the file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (rid, ' '.join(args), file_name, stdoutdata.decode('utf-8'), stderrdata.decode('utf-8')))
                    return 1

        return 0
                
    """
    Get the image resolution based on the formula "(int) (10**6 / float(physicalSizeX))"
    """
    def getResolution(self, metadata, rid):
        try:
            resolutions = []
            for image in metadata.iter(self.image_tag):
                self.logger.debug('Found <Image> tag')
                pixels_element = image.find(self.pixels_tag)
                if pixels_element is None:
                    self.logger.debug('Not found <Pixel> tag')
                    continue
                pixels = pixels_element.attrib
                if pixels is None:
                    self.logger.debug('Not found "pixels" attributes')
                    continue
                if self.physicalSizeXUnit not in pixels.keys():
                    self.logger.debug('Not found "physicalSizeXUnit" attribute')
                    continue
                physicalSizeXUnit = pixels[self.physicalSizeXUnit]
                if physicalSizeXUnit not in self.micrometer:
                    self.logger.debug('Unknown physicalSizeXUnit: {}'.format(physicalSizeXUnit))
                    continue
                if self.physicalSizeX not in pixels.keys():
                    self.logger.debug('"PhysicalSizeX" attribute is missing')
                    continue
                physicalSizeX = pixels[self.physicalSizeX]
                if physicalSizeX is None:
                    self.logger.debug('No value found for "PhysicalSizeX"')
                    continue
                resolution = (int) (10**6 / float(physicalSizeX))
                if resolution not in resolutions:
                    resolutions.append(resolution)
            return resolutions
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE IMAGE PROCESSING: Can not get the resolution', 'RID: %s\n%s\n' % (rid, ''.join(traceback.format_exception(et, ev, tb))))
            return None
    """
    Get the image resolution based on the formula "(int) (10**6 / float(physicalSizeX))"
    """
    def getPixelsPerMeter(self, physicalSizeXUnit, physicalSizeX, rid):
        try:
            pixels_per_meter = None
            if physicalSizeXUnit not in self.micrometer:
                self.logger.debug('Unknown physicalSizeXUnit: {}'.format(physicalSizeXUnit))
            else:
                pixels_per_meter = (int) (10**6 / float(physicalSizeX))

            return pixels_per_meter
            
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE IMAGE PROCESSING: Can not get the resolution', 'RID: %s\n%s\n' % (rid, ''.join(traceback.format_exception(et, ev, tb))))
            return None
    """
    Convert the file to a tiled pyramid
    """
    def convert2pyramid(self, filename, rid):
        try:
            currentDirectory=os.getcwd()
            os.chdir(self.data_scratch)
            args = [self.python_app, self.extract_scenes, filename]
            self.logger.debug('Executing:\n%s' % (' '.join(args)))
            p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdoutdata, stderrdata = p.communicate()
            returncode = p.returncode
            os.chdir(currentDirectory)
            self.logger.debug('\n{}\n'.format(stdoutdata))
            if returncode != 0:
                self.logger.debug('extract_scenes.py failed')
                self.logger.error('Can not extract_scenes.py for file "%s", RID: "%s".\nError Code:%d\nstdoutdata: %s\nstderrdata: %s\n' % (filename, rid, returncode, stdoutdata, stderrdata.decode('utf-8'))) 
                self.sendMail('FAILURE IMAGE PROCESSING: Extrac Scenes failed', 'RID: %s\nCan not extract_scenes for file "%s".\nCommand:\n%s\nError Code:%d\nstdoutdata: %s\nstderrdata: %s\n' % (rid, filename, ' '.join(args), returncode, stdoutdata, stderrdata.decode('utf-8')))
                os.remove(filename)
                return returncode

            image_file = os.path.basename(filename)
            fname, ext = os.path.splitext(image_file)
            
            for entry in os.scandir('{}/{}'.format(self.data_scratch, fname)):
                if entry.is_dir() and entry.path.endswith('.zarr'):
                    self.logger.debug('Removing directory "%s"' % (entry.path))
                    shutil.rmtree(entry.path)
                elif entry.is_file() and entry.path.endswith('.json'):
                    f = open(entry.path, 'r')
                    series_details = json.load(f)
                    f.close()
                    series_details = sorted(series_details, key=lambda obj: obj['Number'])
                    self.json = entry.name

            """
            Remove the Thumbnail series
            """
            thumbnail_series = []
            
            for scene in series_details:
                if scene['Thumbnail series'] == True:
                    thumbnail_series.append(scene['Number'])
            
            if len(thumbnail_series) == len(series_details):
                """
                Keep only the first thumbnail
                """
                self.missing_scenes = True
                thumbnail_series = thumbnail_series[0:1]
                for scene in series_details:
                    if scene['Number'] == thumbnail_series[0]:
                        scene['Thumbnail series'] = False
            
            scenes_dir = '{}/{}'.format(self.data_scratch, fname)
            
            prefix = fname
            
            for file_name in os.listdir(scenes_dir):
                if os.path.isfile('{}/{}'.format(scenes_dir, file_name)):
                    try:
                        r = re.search('{}[-]s([0-9]+)[-]z.*'.format(prefix), file_name).group(1)
                        if int(r) in thumbnail_series:
                            os.remove('{}/{}'.format(scenes_dir, file_name))
                    except:
                        pass
            
                    try:
                        r = re.search('{}[-]s([0-9]+)[.]companion[.]ome'.format(prefix), file_name).group(1)
                        if int(r) in thumbnail_series:
                            os.remove('{}/{}'.format(scenes_dir, file_name))
                    except:
                        pass
            
            if self.physicalSizeXUnit in series_details[0].keys() and self.physicalSizeX in series_details[0].keys():
                if series_details[0][self.physicalSizeXUnit] in self.micrometer:
                    self.resolutions = [(int) (10**6 / float(series_details[0][self.physicalSizeX]))]
                    
            for entry in os.scandir('{}/{}'.format(self.data_scratch, fname)):
                if entry.is_file() and entry.path.endswith('.companion.ome'):
                    self.ome_xml.append(entry.name)
            
            for entry in os.scandir('{}/{}'.format(self.data_scratch, fname)):
                if entry.is_file() and (entry.path.endswith('.json') or entry.path.endswith('.companion.ome')):
                    shutil.copy(entry.path, '/var/www/html/{}'.format(self.output_metadata))
            
            for entry in os.scandir('{}/{}'.format(self.data_scratch, fname)):
                if entry.is_file() and entry.path.endswith('ome.tif'):
                    try:
                        r = re.search('(.*)[-](s[0-9]+)[-](z[0-9]+)[-](c[0-9]+)[.]ome[.]tif$', entry.name)
                        name = r.group(1)
                        series = r.group(2)[1:]
                        z_index = r.group(3)[1:]
                        channel_number = r.group(4)[1:]
                        fr = TiffFile(entry.path)
                        is_ome = fr.ome_metadata != None
                        fr.close()
                        series_properties = {}
                        crt_series = series_details[int(series)]
                        for key in ['SizeX', 'SizeY', 'SizeZ', 'SizeT', 'SizeC', 'PhysicalSizeX', 'PhysicalSizeY', 'PhysicalSizeZ', 'PhysicalSizeXUnit', 'PhysicalSizeYUnit', 'PhysicalSizeZUnit', 'X', 'Y', 'Z', 'XUnit', 'YUnit', 'ZUnit']:
                            if key in crt_series.keys():
                                series_properties[key] = crt_series[key]
                        series_properties['SizeC'] = len(series_details[int(series)]['Channels'])

                        self.tiff_files.append({ 'name': entry.name,
                                               'series_details': series_details[int(series)],
                                               'series_properties': series_properties,
                                               'series': int(series),
                                               'channel': int(channel_number),
                                               'IS_RGB': series_details[int(series)]['RGB'],
                                               'is_ome': is_ome,
                                               'channel_name': series_details[int(series)]['Channels'][int(channel_number)].get('Name', 'Unknown'),
                                               'channel_color': series_details[int(series)]['Channels'][int(channel_number)].get('Color', None),
                                               'z': int(z_index)})
                        self.tiff_images.append(entry.name)
                        shutil.copy(entry.path, '/var/www/html/{}'.format(self.images))
                    except:
                        try:
                            fr = TiffFile(entry.path)
                            is_ome = fr.ome_metadata != None
                            fr.close()
                        except:
                            is_ome = None
                        self.ome_tiff_files.append({ 'name': entry.name,
                                                   'series_details': series_details,
                                                   'series': None,
                                                   'channel': None,
                                                   'IS_RGB': None,
                                                   'is_ome': is_ome,
                                                   'channel_name': None,
                                                   'channel_color': None,
                                                   'z': None})
                        self.ome_tiff_images.append(entry.name)
                        shutil.copy(entry.path, '/var/www/html/{}'.format(self.images))

            shutil.rmtree('{}/{}'.format(self.data_scratch, fname))
            os.remove(filename)
            
            """
            Remove the hidden files
            """
            for file_name in os.listdir(self.data_scratch):
                if os.path.isfile('{}/{}'.format(self.data_scratch, file_name)) and file_name.startswith('.'):
                    os.remove('{}/{}'.format(self.data_scratch, file_name))
            
            """
            Adjust the series level
            """
            series_min = None
            for pyramid in self.tiff_files:
                if series_min == None:
                    series_min = pyramid['series']
                elif pyramid['series'] < series_min:
                    series_min = pyramid['series']
                    
            if series_min > 0:
                for pyramid in self.tiff_files:
                    pyramid['series'] = pyramid['series'] - series_min

            return returncode
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE IMAGE PROCESSING: CONVERT TO PYRAMID ERROR', 'RID: %s\n%s\n' % (rid, ''.join(traceback.format_exception(et, ev, tb))))
            try:
                os.remove('{}/.{}.bfmemo'.format(os.path.dirname(filename), os.path.basename(filename)))
            except FileNotFoundError:
                pass
            os.remove(filename)
            return 1
            
    """
    Update the ermrest attributes 
    """
    def updateAttributes (self, schema, table, rid, columns, row):
        """
        Update the ermrest attributes with the row values.
        """
        try:
            columns = ','.join([urlquote(col) for col in columns])
            url = '/attributegroup/{}:{}/RID;{}'.format(urlquote(schema), urlquote(table), columns)
            resp = self.catalog.put(
                url,
                json=[row]
            )
            resp.raise_for_status()
            self.logger.debug('SUCCEEDED updated the table "{}.{}" for the RID {} using the URL "{}" with {}'.format(schema, table, rid, url, json.dumps(row, indent=4))) 
            return 0
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE IMAGE PROCESSING: STATE CHANGE ONCE ERROR', 'RID: %s\n%s\n' % (rid, ''.join(traceback.format_exception(et, ev, tb))))
            return 1
            
    """
    Delete the rows referencing the source image
    """
    def deleteEntity (self, path, rid):
        """
        Delete the rows from the table.
        """
        try:
            url = '/entity/{}'.format(path)
            resp = self.catalog.delete(
                url
            )
            resp.raise_for_status()
            self.logger.debug('SUCCEEDED deleted the rows for the URL "%s" referencing the TIFF image "%s".' % (url, rid)) 
            return 0
        except HTTPError as e:
            if e.response.status_code == HTTPStatus.NOT_FOUND:
                self.logger.debug('No rows found to delete from the URL "%s" referencing the TIFF image "%s".' % (url, rid))
                return 0
            else:
                et, ev, tb = sys.exc_info()
                self.logger.error('got exception "%s"' % str(ev))
                self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                self.sendMail('FAILURE IMAGE PROCESSING: DELETE ENTITY ERROR', 'RID: %s\n%s\n' % (rid, ''.join(traceback.format_exception(et, ev, tb))))
                return 1
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE IMAGE PROCESSING: DELETE ENTITY ERROR', 'RID: %s\n%s\n' % (rid, ''.join(traceback.format_exception(et, ev, tb))))
            return 1

    """
    Insert a row in a table
    """
    def createEntity (self, path, row, rid):
        """
        Insert the row in the table.
        """
        try:
            url = '/entity/{}'.format(path)
            resp = self.catalog.post(
                url,
                json=[row]
            )
            resp.raise_for_status()
            
            self.logger.debug('SUCCEEDED created in the table "%s" the entry "%s".' % (url, json.dumps(row, indent=4))) 
            return url
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE IMAGE PROCESSING: CREATE ENTITY ERROR', 'RID: %s\n%s\n' % (rid, ''.join(traceback.format_exception(et, ev, tb))))
            return None

    """
    Insert a row into a table specified by the url
    """
    def createRecord (self, url, row, rid):
        """
        Insert the row into the table referred by the url.
        """
        try:
            resp = self.catalog.post(
                url,
                json=[row]
            )
            resp.raise_for_status()
            
            new_rid = resp.json()[0]['RID']
            self.logger.debug('SUCCEEDED created in the table "%s" the entry "%s".' % (url, json.dumps(row, indent=4))) 
            return new_rid
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE IMAGE PROCESSING: CREATE ENTITY ERROR', 'RID: %s\n%s\n' % (rid, ''.join(traceback.format_exception(et, ev, tb))))
            return None

    """
    Remove the files resulted from the conversion and metadata.
    """
    def removeConvertedFiles(self):
        for file_name in os.listdir('/var/www/html/%s' % (self.images)):
            file_path = '/var/www/html/%s%s%s' % (self.images, os.sep, file_name)
            if os.path.isfile(file_path):
                self.logger.debug('Removing file "%s"' % (file_path))
                os.remove(file_path)
        for file_name in os.listdir('/var/www/html/%s' % (self.output_metadata)):
            file_path = '/var/www/html/%s%s%s' % (self.output_metadata, os.sep, file_name)
            if os.path.isfile(file_path):
                self.logger.debug('Removing file "%s"' % (file_path))
                os.remove(file_path)

        
    """
    Cleanup the scratch directory.
    """
    def cleanupDataScratch(self):
        for file_name in os.listdir(self.data_scratch):
            file_path = '{}/{}'.format(self.data_scratch, file_name)
            if os.path.isfile(file_path):
                self.logger.debug('Removing file "{}"'.format(file_path))
                os.remove(file_path)
            elif os.path.isdir(file_path):
                self.logger.debug('Removing directory "{}"'.format(file_path))
                shutil.rmtree(file_path)
        
    """
    Store the file into hatrac
    """
    def storeFileInHatrac(self, file_name, file_path, rid):
        try:
            newFile = '{}/{}'.format(file_path, file_name)
            file_size = os.path.getsize(newFile)
            hashes = hu.compute_file_hashes(newFile, hashes=['md5', 'sha256'])
            new_md5 = hashes['md5'][1]
            new_sha256 = hashes['sha256'][1]
            hexa_md5 = hashes['md5'][0]
            base_md5 = self.getBaseMD5(file_name, file_path)
            hexa_sha256 = hashes['sha256'][0]
            new_uri = '{}/{}/{}'.format(self.hatrac_prefix, urlquote(rid), urlquote(file_name))
            chunked = True if file_size > DEFAULT_CHUNK_SIZE else False
            
            """
            Store the images in hatrac if they are not already
            """
            hatrac_URI = None
            try:
                outfile = '/var/www/html/{}/{}.hatrac'.format(self.images, file_name)
                r = self.store.get_obj(new_uri, destfilename=outfile)
                hatrac_URI = r.headers['Content-Location']
                hatrac_base_md5 = self.getBaseMD5('{}.hatrac'.format(file_name))
                os.remove(outfile)
            except:
                hatrac_base_md5 = None
                pass
                
            
            if hatrac_URI != None and base_md5 == hatrac_base_md5:
                self.logger.info('Skipping the upload of the file "%s" as it already exists hatrac.' % file_name)
            else:
                if mimetypes.inited == False:
                    mimetypes.init()
                content_type,encoding = mimetypes.guess_type(newFile)
                if content_type == None:
                    content_type = 'application/octet-stream'
                try:
                    hatrac_URI = self.hatrac_store.put_loc(new_uri,
                                                         newFile,
                                                         headers={'Content-Type': content_type},
                                                         content_disposition = "filename*=UTF-8''%s" % urlquote(file_name),
                                                         md5 = new_md5,
                                                         sha256 = new_sha256,
                                                         content_type = content_type,
                                                         chunked = chunked
                                                       )
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('Can not upload file "%s" in hatrac "%s". Error: "%s"' % (file_name, new_uri, str(ev)))
                    self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                    self.sendMail('FAILURE IMAGE PROCESSING: HATRAC PUT ERROR', 'RID: %s\nCan not upload file "%s" in hatrac "%s". Error: "%s"' % (rid, file_name, new_uri, ''.join(traceback.format_exception(et, ev, tb))))
                    return (None, None, None, None)
            return (hatrac_URI, file_name, file_size, hexa_md5)

        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE IMAGE PROCESSING: HATRAC STORE ERROR', 'RID: %s\n%s\n' % (rid, ''.join(traceback.format_exception(et, ev, tb))))
            return (None, None, None, None)
        

